% Showcase Präsentation mit SimSchoolDark Theme
\documentclass{beamer}

% Theme laden
\usetheme{SimSchoolDark}

% Für Python Code Highlighting
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage[T1]{fontenc}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.45,0.45,0.45}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen}\itshape,
	keywordstyle=\color{magenta}\bfseries,
	stringstyle=\color{codepurple},
	numberstyle=\tiny\color{codegray},
	basicstyle=\ttfamily\small,  % kompakter als footnotesize, aber noch gut lesbar
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=none,                % ich empfehle in Beamer lieber keine Zeilennummern
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,                   % einheitlich 4 Spaces für Tabs
	frame=single,                % optional: Rahmen um den Code
	rulecolor=\color{gray!50},   % dezente Rahmenfarbe
	aboveskip=5pt,
	belowskip=5pt,
	xleftmargin=4pt, xrightmargin=4pt,
	columns=fullflexible         % sorgt für gleichmäßige Zeichenabstände
}

\lstset{style=mystyle}

% Python Code Style
%\lstset{
	%	language=Python,
	%	basicstyle=\ttfamily\small,
	%	keywordstyle=\color{simschooldarkest}\bfseries,
	%	stringstyle=\color{simschoolmedium},
	%	commentstyle=\color{simschoollight}\itshape,
	%	numberstyle=\tiny\color{simschoollight},
	%	numbers=left,
	%	breaklines=true,
	%	frame=single,
	%	rulecolor=\color{simschoolmedium},
	%	backgroundcolor=\color{simschoolbg!50},
	%	showstringspaces=false,
	%	tabsize=4
	%}

% Präsentationsinfos
\title{ARM-Embedded-Path}
\subtitle{Bitmasking}
\author{Pavel Pys}
\date{\today}
%\institute{}
\begin{document}
	\begin{frame}
		\maketitle
	\end{frame}
	\section{Bitmasking}
	\begin{frame}
		\frametitle{Bit-Masking Basics}
		\textbf{How does \texttt{((GPIOB->IDR \& (1<<5)) == 0)} actually work?}
		
		\medskip
		\textbf{Goal:} We want to know: "Is Pin 5 LOW (0)?"
		\bigskip
		\begin{itemize}
			\item We need to isolate Pin 5's state...
			\begin{itemize}
				\item ...from 31 other (irrelevant) bits.
			\end{itemize}
			\item We use "Bit-Masking" for this.
		\end{itemize}
		
		\bigskip
		\textbf{The 3 Steps:}
		\begin{enumerate}
			\item \texttt{(1<<5)} $\rightarrow$ Create the "mask" (template).
			\item \texttt{... \& ...} $\rightarrow$ Apply the mask (Isolate).
			\item \texttt{... == 0} $\rightarrow$ Check the result.
		\end{enumerate}
	\end{frame}
	
	% --- FRAME 2: Step 1: The Mask (1<<5) ---
	\begin{frame}[fragile]
		\frametitle{Step 1: The "Mask" \texttt{(1<<5)}}
		\textbf{\texttt{<<} is the "Bit-Shift Operator".}
		(Shift bits left)
		
		\medskip
		\textbf{1. Start with number 1:}
		\begin{verbatim}
			0000 0000 0000 0000 0000 0000 0000 0001
		\end{verbatim}
		
		\medskip
		\textbf{2. Shift it 5 positions left:}
		\begin{verbatim}
			... 0000 0001  (Start)
			... 0000 0010  (<< 1)
			... 0000 0100  (<< 2)
			... 0000 1000  (<< 3)
			... 0001 0000  (<< 4)
			... 0010 0000  (<< 5)  <- This is Pin 5!
		\end{verbatim}
		
		\textbf{Result \texttt{(1<<5)} is our mask:}
		\begin{verbatim}
			0000 0000 ... 0000 0010 0000  (Value: 32)
		\end{verbatim}
		\textbf{Remember:} This is a number with \textbf{1} only at bit position 5.
		Everywhere else is \textbf{0}.
	\end{frame}
	
	% --- FRAME 3: Step 2: Isolation (&) ---
	\begin{frame}[fragile]
		\frametitle{Step 2: Isolation (Bitwise-AND / \texttt{\&})}
		\textbf{\texttt{\&}} applies our mask to the read value.
		Works like a "light filter".
		
		\medskip
		\textbf{Rule (Bit by bit):}
		\begin{itemize}
			\item \texttt{1 \& 1} $\rightarrow$ \texttt{1} (light passes through)
			\item \texttt{1 \& 0} $\rightarrow$ \texttt{0}
			\item \texttt{0 \& 1} $\rightarrow$ \texttt{0}
			\item \texttt{0 \& 0} $\rightarrow$ \texttt{0}
		\end{itemize}
		\medskip
		\textbf{What happens:}
		Wherever our mask has \textbf{0}, the result is \textbf{ALWAYS 0}
		(regardless of \texttt{IDR} value).
		\medskip
		Only at the \textbf{single} position (Pin 5), where our mask has \textbf{1},
		the actual value of Pin 5 "shines through"!
	\end{frame}
	
	% --- FRAME 4: Case A ---
	\begin{frame}[fragile]
		\frametitle{Step 2: Case A (Button NOT pressed)}
		\textbf{Assumption:} Pin 5 is HIGH (1).
		
		\begin{verbatim}
			... 0010 0100   (Example: GPIOB->IDR)
			(Pin 5 is 1, Pin 2 is 1)
			& 000 0010 0000   (Our mask (1<<5))
			-------------------------------------------
			= 000 0010 0000   (Result is 32, so NOT ZERO)
		\end{verbatim}
		\medskip
		\textbf{Explanation:}
		\begin{itemize}
			\item At Pin 2: \texttt{IDR(1) \& MASK(0) = 0} (filtered out)
			\item At Pin 5: \texttt{IDR(1) \& MASK(1) = 1} (came through!)
		\end{itemize}
		The result is \textbf{\texttt{(1<<5)}}.
	\end{frame}
	
	% --- FRAME 5: Case B ---
	\begin{frame}[fragile]
		\frametitle{Step 2: Case B (Button PRESSED)}
		\textbf{Assumption:} Pin 5 is LOW (0).
		
		\begin{verbatim}
			... 0000 0100   (Example: GPIOB->IDR)
			(Pin 5 is 0, Pin 2 is 1)
			& 000 0010 0000   (Our mask (1<<5))
			-------------------------------------------
			= 000 0000 0000   (Result is 0, so ZERO)
		\end{verbatim}
		\medskip
		\textbf{Explanation:}
		\begin{itemize}
			\item At Pin 2: \texttt{IDR(1) \& MASK(0) = 0} (filtered out)
			\item At Pin 5: \texttt{IDR(0) \& MASK(1) = 0} (came through, but was 0!)
		\end{itemize}
		The result is \textbf{\texttt{0}}.
	\end{frame}
	
	% --- FRAME 6: Step 3: Comparison (== 0) ---
	\begin{frame}[fragile]
		\frametitle{Step 3: Comparison \texttt{(... == 0)}}
		This part is now super simple. In step 2 we
		"erased" all 31 irrelevant bits.
		
		\medskip
		We just ask: "Is the overall result of our
		isolation operation ZERO?"
		
		\bigskip
		\begin{lstlisting}[language=C, style=mystyle]
			if ( ((... & (1<<5)) == 0) )
		\end{lstlisting}
		
		\begin{itemize}
			\item \textbf{If result is \texttt{0}:}
			\begin{itemize}
				\item (Case B occurred)
				\item The bit at Pin 5 \textit{must} have been 0.
				\item $\rightarrow$ \textbf{Button is pressed!}
			\end{itemize}
			\medskip
			\item \textbf{If result is \texttt{not 0} (i.e., 32):}
			\begin{itemize}
				\item (Case A occurred)
				\item The bit at Pin 5 \textit{must} have been 1.
				\item $\rightarrow$ \textbf{Button is released!}
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	% --- FRAME 7: Conclusion ---
	\begin{frame}[fragile]
		\frametitle{Bit-Masking: Conclusion}
		\textbf{\texttt{((GPIOB->IDR \& (1<<5)) == 0)}}
		
		\begin{itemize}
			\item \textbf{\texttt{(1<<5)}} $\rightarrow$ "Build me a mask with a
			hole only at Pin 5."
			\medskip
			\item \textbf{\texttt{\&}} $\rightarrow$ "Apply the mask to the register
			to isolate Pin 5."
			\medskip
			\item \textbf{\texttt{== 0}} $\rightarrow$ "Check if the isolated value
			(i.e., Pin 5) was zero."
		\end{itemize}
		\bigskip
		\bigskip
		\textbf{What about \texttt{GPIO\_IDR\_IDR5}?}
		\begin{itemize}
			\item That's just the CMSIS name for \texttt{(1<<5)}.
			\item \texttt{((GPIOB->IDR \& GPIO\_IDR\_IDR5) == 0)}
			is exactly the same code.
		\end{itemize}
	\end{frame}
	% --- FRAME 8 (NEW): The 4 Most Important Bit Operators ---
	\begin{frame}
		\frametitle{The 4 Most Important Bit Operators}
		Your "Swiss Army knife" for registers.
		
		\medskip
		\begin{itemize}
			\item \textbf{\texttt{\&} (AND)}: \textbf{The Isolator / Filter}
			\begin{itemize}
				\item "Show me \textit{only} the bits I care about."
				\item \texttt{1 \& 1 = 1}, \texttt{1 \& 0 = 0}, \texttt{0 \& 0 = 0}
				\item (Used for \textit{checking} in previous slides)
			\end{itemize}
			\medskip
			\item \textbf{\texttt{|} (OR)}: \textbf{The Setter / Combiner}
			\begin{itemize}
				\item "Set this bit to 1, but leave the rest alone."
				\item \texttt{1 | 1 = 1}, \texttt{1 | 0 = 1}, \texttt{0 | 0 = 0}
			\end{itemize}
			\medskip
			\item \textbf{\texttt{\textasciitilde{}} (NOT)}: \textbf{The Inverter}
			\begin{itemize}
				\item "Flip \textit{all} 32 bits."
				\item \texttt{\textasciitilde{}1 = 0}, \texttt{\textasciitilde{}0 = 1}
			\end{itemize}
			\medskip
			\item \textbf{\texttt{\^} (XOR)}: \textbf{The Toggler}
			\begin{itemize}
				\item "Flip \textit{only} this one bit (0->1 or 1->0)."
				\item \texttt{1 \^ 1 = 0}, \texttt{1 \^ 0 = 1}, \texttt{0 \^ 0 = 0}
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	% --- FRAME 9 (NEW): The "Shortcut" (|=, &=) ---
	\begin{frame}[fragile]
		\frametitle{The C Shortcut: \texttt{|=} and \texttt{\&=}}
		These are "assignment operators".
		
		\medskip
		\textbf{Analogy:} You know this from math:
		\begin{itemize}
			\item \texttt{x = x + 10;} is the same as \texttt{x += 10;}
		\end{itemize}
		
		\medskip
		\textbf{For bit operations it's exactly the same:}
		\begin{itemize}
			\item \texttt{x = x | MASK;} (long) $\rightarrow$ \textbf{\texttt{x |= MASK;}} (short)
			\item \texttt{x = x \& MASK;} (long) $\rightarrow$ \textbf{\texttt{x \&= MASK;}} (short)
			\item \texttt{x = x \^ MASK;} (long) $\rightarrow$ \textbf{\texttt{x \^= MASK;}} (short)
		\end{itemize}
		\medskip
		\textbf{Remember:} \texttt{|=} and \texttt{\&=} aren't "magic", just
		C syntax sugar (shortcuts) for a
		\textbf{"Read-Modify-Write" operation}.
	\end{frame}
	
	% --- FRAME 10 (NEW): Pattern 1: SET a Bit (|=) ---
	\begin{frame}[fragile]
		\frametitle{Pattern 1: SET a Bit (with \texttt{|=})}
		\textbf{Goal:} We want to turn Pin 5 (LED) ON (set to 1).
		But we must not change the other 31 bits!
		
		\medskip
		\textbf{Tool: \texttt{|} (OR)}
		\begin{itemize}
			\item \texttt{...Original... | 0} $\rightarrow$ \texttt{...Original...} (unchanged)
			\item \texttt{...Original... | 1} $\rightarrow$ \textbf{\texttt{1}} (forced to 1)
		\end{itemize}
		\medskip
		\textbf{The Operation:}
		\begin{lstlisting}[language=C, style=mystyle, basicstyle=\footnotesize]
			// This is the "Set-Pin-5" command
			GPIOB->ODR |= (1U<<5); // (or GPIO_ODR_ODR5)
		\end{lstlisting}
		
		\begin{verbatim}
			... 0000 0100   (Original value in ODR register)
			| ... 0010 0000   (Our mask (1<<5))
			-------------------------------------------
			= ... 0010 0100   (Result: Pin 5 is ON, Pin 2 stayed ON)
		\end{verbatim}
	\end{frame}
	
	% --- FRAME 11 (NEW, SPLIT): Pattern 2: CLEAR (Concept) ---
	\begin{frame}[fragile]
		\frametitle{Pattern 2: CLEAR a Bit (Concept)}
		\textbf{Goal:} We want to turn Pin 5 (LED) OFF (set to 0).
		But we must not change the other 31 bits!
		
		\medskip
		\textbf{Tools: \texttt{\textasciitilde{}} (NOT) and \texttt{\&} (AND)}
		This is the "pro" move. (You used this unconsciously in your \texttt{LED\_Init}
		with \texttt{\&= \~(0xF<<20)}!)
		
		\medskip
		\textbf{Step 1: The mask (Pin 5)} $\rightarrow$ \texttt{(1<<5)}
		\begin{verbatim}
			... 0010 0000
		\end{verbatim}
		
		\medskip
		\textbf{Step 2: The "Anti-Mask" (Invert)} $\rightarrow$ \texttt{\~(1<<5)}
		\begin{verbatim}
			... 1101 1111  (All 1s, EXCEPT at Pin 5)
		\end{verbatim}
	\end{frame}
	
	% --- FRAME 12 (NEW, SPLIT): Pattern 2: CLEAR (Code) ---
	\begin{frame}[fragile]
		\frametitle{Pattern 2: CLEAR a Bit (Code \texttt{\&= \~{}})}
		\textbf{Step 3: The Filtering (AND)}
		The "anti-mask" is \texttt{\&}-combined.
		
		\medskip
		\textbf{The Operation:}
		\begin{lstlisting}[language=C, style=mystyle, basicstyle=\footnotesize]
			// This is the "Clear-Pin-5" command
			REG &= ~(1U<<5);
		\end{lstlisting}
		
		\begin{verbatim}
			... 0010 0100   (Original value in register)
			& ... 1101 1111   (Our "anti-mask" from slide 11)
			-------------------------------------------
			= ... 0000 0100 (Result: Pin 5 is OFF, Pin 2 stayed ON)
		\end{verbatim}
	\end{frame}
	
	% --- FRAME 12b (NEW): Atomic Set/Reset with BSRR ---
	\begin{frame}[fragile]
		\frametitle{STM32F1: Atomic Set/Reset with \texttt{BSRR} (Recommended)}
		\textbf{Why?} Avoid read-modify-write hazards on \texttt{ODR} and update a single bit atomically.
		
		\medskip
		\textbf{Use \texttt{GPIOx\_BSRR}:}
		\begin{itemize}
			\item \textbf{Set bit \texttt{y}}: \texttt{GPIOB->BSRR = (1U << y);} \hfill (writes to \texttt{BSy})
			\item \textbf{Reset bit \texttt{y}}: \texttt{GPIOB->BSRR = (1U << (y+16));} \hfill (writes to \texttt{BRy})
			\item (On F1 there is also \texttt{BRR}: \texttt{GPIOB->BRR = (1U << y);} to reset.)
		\end{itemize}
		
		\medskip
		\textbf{Note (RM0008):} \emph{“For atomic bit set/reset, the ODR bits can be individually set and cleared by writing to the \texttt{GPIOx\_BSRR} register.”}
	\end{frame}
	
	
	% --- FRAME 13 (NEW, SPLIT): Pro Tip: TOGGLE (Concept) ---
	\begin{frame}[fragile]
		\frametitle{Pro Tip: TOGGLE a Bit (with \texttt{\^=})}
		\textbf{Goal:} "Flip" Pin 5's state (ON->OFF, OFF->ON).
		Ideal for blinkers, without \texttt{if/else}!
		
		\medskip
		\textbf{Tool: \texttt{\^} (XOR)}
		\begin{itemize}
			\item \texttt{...Original... \^ 0} $\rightarrow$ \texttt{...Original...} (unchanged)
			\item \texttt{...Original... \^ 1} $\rightarrow$ \textbf{\texttt{...Inverted...}} (flipped)
		\end{itemize}
		\medskip
		\textbf{The Operation:}
		\begin{lstlisting}[language=C, style=mystyle, basicstyle=\footnotesize]
			// This is the "light switch" command
			GPIOB->ODR ^= (1U<<5);
		\end{lstlisting}
	\end{frame}
	
	% --- FRAME 14 (NEW, SPLIT): Pro Tip: TOGGLE (The 2 Cases) ---
	\begin{frame}[fragile]
		\frametitle{Pro Tip: TOGGLE (The 2 Cases)}
		
		\textbf{Case A (LED was OFF):}
		\begin{verbatim}
			... 0000 0000   (Original ODR)
			^ ... 0010 0000   (Mask (1<<5))
			-------------------------------------------
			= ... 0010 0000   (Result: LED is ON)
		\end{verbatim}
		
		\medskip
		\textbf{Case B (LED was ON):}
		\begin{verbatim}
			... 0010 0000   (Original ODR)
			^ ... 0010 0000   (Mask (1<<5))
			-------------------------------------------
			= ... 0000 0000   (Result: LED is OFF)
		\end{verbatim}
	\end{frame}
	
	% --- FRAME 15 (NEW, SPLIT): Cheat Sheet (Part 1) ---
	\begin{frame}[fragile]
		\frametitle{Cheat Sheet: Bit Operations (Part 1)}
		\textbf{Your toolbox for register programming}
		
		\medskip
		\begin{itemize}
			\item \textbf{Isolate / Check (if LOW):}
			\begin{itemize}
				\item \texttt{if ((REG \& (1<<5)) == 0) ...}
			\end{itemize}
			\medskip
			\item \textbf{SET Bit (to 1):}
			\begin{itemize}
				\item \texttt{REG |= (1<<5);}
			\end{itemize}
		\end{itemize}
	\end{frame}
	
	% --- FRAME 16 (NEW, SPLIT): Cheat Sheet (Part 2) ---
	\begin{frame}[fragile]
		\frametitle{Cheat Sheet: Bit Operations (Part 2)}
		\textbf{Your toolbox for register programming}
		
		\medskip
		\begin{itemize}
			\item \textbf{CLEAR Bit (to 0):}
			\begin{itemize}
				\item \texttt{REG \&= \string~(1U<<5);}
			\end{itemize}
			\medskip
			\item \textbf{TOGGLE Bit (flip):}
			\begin{itemize}
				\item \texttt{REG \string^= (1U<<5);}
			\end{itemize}
			\medskip
			\item \textbf{CLEAR 4-Bit Block (e.g., Pin 13):}
			\begin{itemize}
				\item \texttt{REG \&= \string~(0xFU << 20);}
			\end{itemize}
		\end{itemize}
	\end{frame}
\end{document}