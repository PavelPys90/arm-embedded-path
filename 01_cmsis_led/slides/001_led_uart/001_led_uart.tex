% Showcase Präsentation mit SimSchoolDark Theme
\documentclass{beamer}

% Theme laden
\usetheme{SimSchoolDark}

% Für Python Code Highlighting
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tabu}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage[T1]{fontenc}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.45,0.45,0.45}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.96,0.96,0.96}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},
	commentstyle=\color{codegreen}\itshape,
	keywordstyle=\color{magenta}\bfseries,
	stringstyle=\color{codepurple},
	numberstyle=\tiny\color{codegray},
	basicstyle=\ttfamily\small,  % kompakter als footnotesize, aber noch gut lesbar
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=none,                % ich empfehle in Beamer lieber keine Zeilennummern
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,                   % einheitlich 4 Spaces für Tabs
	frame=single,                % optional: Rahmen um den Code
	rulecolor=\color{gray!50},   % dezente Rahmenfarbe
	aboveskip=5pt,
	belowskip=5pt,
	xleftmargin=4pt, xrightmargin=4pt,
	columns=fullflexible         % sorgt für gleichmäßige Zeichenabstände
}

\lstset{style=mystyle}

% Python Code Style
%\lstset{
%	language=Python,
%	basicstyle=\ttfamily\small,
%	keywordstyle=\color{simschooldarkest}\bfseries,
%	stringstyle=\color{simschoolmedium},
%	commentstyle=\color{simschoollight}\itshape,
%	numberstyle=\tiny\color{simschoollight},
%	numbers=left,
%	breaklines=true,
%	frame=single,
%	rulecolor=\color{simschoolmedium},
%	backgroundcolor=\color{simschoolbg!50},
%	showstringspaces=false,
%	tabsize=4
%}

% Präsentationsinfos
\title{ARM-Embedded-Path}
\subtitle{LED - UART}
\author{Pavel Pys}
\date{\today}
%\institute{}
\begin{document}
\begin{frame}{}
	\maketitle
\end{frame}
\begin{frame}{Overview}
	\tableofcontents
\end{frame}
% --- KOMPLETTER FOLIENSATZ TEIL 2 (v2.0) ---

\section{Einleitung \& Motivation}

\begin{frame}{CMSIS Schulung: UART \& Timing}
	\begin{center}
		\Large\textbf{Aufgabe: Der "Morse-Bot"}
		\medskip
		
		\normalsize Von der UART-Eingabe zum getimeten LED-Signal
	\end{center}
\end{frame}
\begin{frame}{Recap: Was war CMSIS?}
	\begin{itemize}
		\item \textbf{Problem:} Jeder ARM-Chip hat andere Adressen für Peripherien (GPIO, Timer...).
		\item \textbf{CMSIS-Core (Cortex-M):} Einheitlicher Zugriff auf Kern-Funktionen (z.B. Interrupts, \texttt{SysTick}).
		\item \textbf{CMSIS-Device (STM32F103):} Stellt Header-Dateien (\texttt{stm32f103x6.h}) bereit.
	\end{itemize}
	
	\medskip
	\textbf{Was wir gelernt haben (Blinky):}
	\begin{enumerate}
		\item Takt für Peripherie (Port C) aktivieren: \texttt{RCC->APB2ENR}
		\item GPIO-Pin (PC13) konfigurieren: \texttt{GPIOC->CRH}
		\item Pin schalten: \texttt{GPIOC->ODR} (oder \texttt{BSRR})
	\end{enumerate}
\end{frame}

\begin{frame}{Motivation: Der 1kB "Blinky"}
	\textbf{Die Beobachtung (Vergleich):}
	
	\medskip
	\begin{columns}
		\column{0.5\textwidth}
		\textbf{Arduino (z.B. ESP8266)}
		\begin{itemize}
			\item "Blinky" (mit \texttt{delay()})
			\item \textbf{\~250+ KByte Flash}
			\item Einfach: \texttt{digitalWrite(D1, HIGH);}
		\end{itemize}
		
		\column{0.5\textwidth}
		\textbf{CMSIS (STM32F103)}
		\begin{itemize}
			\item "Blinky" (mit SysTick)
			\item \textbf{\~1 KByte Flash}
			\item Komplexer: \texttt{GPIOC->BSRR = ...;}
		\end{itemize}
	\end{columns}
	
	\bigskip
	\begin{center}
		\Large\textbf{Wo sind die restlichen 249 KByte?!}
	\end{center}
\end{frame}

\begin{frame}[fragile]{Motivation: Kontrolle statt Komfort}
	\textbf{Antwort: Wir haben keinen "Overhead".}
	
	\medskip
	\textbf{1. Kein Framework-Overhead}
	\begin{itemize}
		\item \textbf{Arduino:} \texttt{digitalWrite(PIN\_NAME);}
		\item \textit{Was passiert:} Ruft 10+ C++ Funktionen auf, übersetzt Pin-Namen in Port/Bit, prüft Timer-Konflikte...
		\item \textbf{CMSIS:} \texttt{GPIOC->BSRR = GPIO\_BSRR\_BR13;}
		\item \textit{Was passiert:} Wird zu 3-4 Maschinenbefehlen übersetzt.
	\end{itemize}
	
	\medskip
	\textbf{2. Kein Betriebssystem (RTOS) / Stacks}
	\begin{itemize}
		\item \textbf{ESP8266:} Lädt *immer* ein FreeRTOS und den WLAN-Stack, nur um \texttt{delay()} auszuführen.
		\item \textbf{Unser Code:} Unser \texttt{Delay\_ms()} sind 3 Zeilen C-Code.
	\end{itemize}
	
	\medskip
	\rightarrow \textbf{Fazit:} Wir tauschen Komfort gegen \textbf{Kontrolle, Effizienz} und \textbf{minimalen Speicherbedarf}.
\end{frame}

\section{Architektur \& Grundlagen}

\begin{frame}{Architektur 1: Timing mit dem SysTick-Timer}
	\begin{itemize}
		\item \textbf{Was ist SysTick?} Ein einfacher 24-Bit "Countdown"-Timer, der \textit{direkt im Cortex-M Kern} sitzt.
		\item \textbf{Wofür?} Ideal als "Taktgeber" für eine simple \texttt{delay}-Funktion.
		\item \textbf{CMSIS-Core Funktion:} \texttt{SysTick\_Config(uint32\_t ticks)}
	\end{itemize}
	\textbf{Die Idee:}
	\begin{enumerate}
		\item Wir konfigurieren den SysTick so, dass er alle \textbf{1ms} einen Interrupt auslöst.
		\item \texttt{SysTick\_Config(SystemCoreClock / 1000);}
		\item \texttt{SystemCoreClock} ist eine globale Variable (aus \texttt{system\_stm32f10xx.c}) mit unserem CPU-Takt (8MHz HSI).
		\item $8.000.000 / 1000 = 8000$ Ticks.
		\item Der SysTick zählt von 8000 auf 0, löst einen Interrupt aus (\texttt{SysTick\_Handler}) und startet neu.
	\end{enumerate}
\end{frame}

\begin{frame}{Architektur 2: Was ist UART (Bare-Metal)?}
	\textbf{Schritt 1: Takt (RCC)}
	\begin{itemize}
		\item Wir brauchen Takt für:
		\begin{itemize}
			\item \texttt{USART1} (die Peripherie selbst)
			\item \texttt{GPIOA} (für die Pins)
			\item \texttt{AFIO} (Alternate Function IO)
		\end{itemize}
		\item Register: \texttt{RCC->APB2ENR}
	\end{itemize}
	
	\textbf{Schritt 2: GPIO (Pins)}
	\begin{itemize}
		\item "Blue Pill" nutzt \texttt{PA9} (TX) und \texttt{PA10} (RX) für \texttt{USART1}.
		\item Konfiguration (im \texttt{GPIOA->CRH} Register):
		\begin{itemize}
			\item \texttt{PA9 (TX)}: \textbf{Alternate Function, Push-Pull}, 10MHz
			\item \texttt{PA10 (RX)}: \textbf{Input, Floating}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Architektur 2: Was ist UART (Bare-Metal)? (Forts.)}
	\textbf{Schritt 3: Baudrate (BRR)}
	\begin{itemize}
		\item Wir müssen einen Divisor (Teiler) berechnen $\rightarrow$ Siehe Exkurs!
		\item Register: \texttt{USART1->BRR}
	\end{itemize}
	
	\textbf{Schritt 4: Aktivierung (CR1)}
	\begin{itemize}
		\item UART aktivieren (\texttt{UE}), Senden (\texttt{TE}), Empfang (\texttt{RE}).
		\item Register: \texttt{USART1->CR1}
	\end{itemize}
\end{frame}

\section{Exkurs: Register-Magie}

\begin{frame}{Exkurs: Bit-Masking (Die Register-Magie)}
	\textbf{Das Problem:}
	\begin{itemize}
		\item Wir wollen Pin \textbf{PA9} konfigurieren (z.B. auf \texttt{1001}).
		\item Wir müssen das 32-Bit Register \texttt{GPIOA->CRH} bearbeiten.
		\item \textbf{Ziel:} Ändere *nur* die 4 Bits für Pin 9, ohne die anderen 7 Pins zu zerstören!
	\end{itemize}
	
	\medskip
	\textbf{Das Register-Layout (\texttt{CRH}):}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			Pin & \dots & Pin 10 & \textbf{Pin 9} & Pin 8 \\ \hline
			Bits & \dots & 11 \quad 10 \quad 9 \quad 8 & \textbf{7 \quad 6 \quad 5 \quad 4} & 3 \quad 2 \quad 1 \quad 0 \\ \hline
		\end{tabular}
	\end{center}
	
	\medskip
	\rightarrow \textbf{Wir müssen die Bits 7, 6, 5 und 4 bearbeiten.}
\end{frame}

\begin{frame}[fragile]{Exkurs: Bit-Masking (Teil 1: Das Konzept)}
	\textbf{Der "Read-Modify-Write" Vorgang}
	\begin{itemize}
		\item Man kann nicht nur 4 Bits schreiben. Man muss das ganze 32-Bit-Register lesen, ändern und zurückschreiben.
		\item Dieser Vorgang hat immer zwei Schritte:
		\begin{enumerate}
			\item \textbf{Löschen (Masking):} Die Ziel-Bits auf 0 setzen (mit \texttt{\&= \~...}).
			\item \textbf{Setzen (Writing):} Die neuen Bits auf 1 setzen (mit \texttt{|= ...}).
		\end{enumerate}
	\end{itemize}
	
	\bigskip
	\textbf{Schritt 1: Die alten Bits für Pin 9 auf 0 setzen.}
	\begin{lstlisting}[language=C, style=mystyle]
		// Kurzform (die wir verwenden):
		GPIOA->CRH &= ~(0xF << 4);
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Exkurs: Bit-Masking (Teil 1: Detail-Analyse)}
	\textbf{Analyse von: \texttt{GPIOA->CRH \&= ~(0xF << 4);}}
	
	\begin{itemize}
		\item \texttt{0xF} $\Rightarrow$ \texttt{0b1111}
		\item \textit{(Unsere 4-Bit "Pin-Maske")}
		
		\medskip
		\item \texttt{(0xF << 4)} $\Rightarrow$ \texttt{0b...0000 1111 0000}
		\item \textit{(Maske wird an die Position von Pin 9 geschoben: Bits 4-7)}
		
		\medskip
		\item \texttt{\~ (0xF << 4)} $\Rightarrow$ \texttt{0b...1111 0000 1111}
		\item \textit{(Die "Lösch-Maske". Nur die Bits 4-7 sind 0)}
		
		\medskip
		\item \texttt{... \&= ...} $\Rightarrow$ (Bitweise UND-Zuweisung)
		\item \textit{(Alles, was mit 1 per UND verknüpft wird, bleibt. Alles, was mit 0 per UND verknüpft wird, wird 0.)}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exkurs: Bit-Masking (Teil 2: Setzen)}
	\textbf{Schritt 2: Die neuen Bits für Pin 9 setzen.}
	\begin{itemize}
		\item Das Register hat jetzt Nullen an der Position von Pin 9.
	\end{itemize}
	
	\bigskip
	\begin{lstlisting}[language=C, style=mystyle]
		GPIOA->CRH |= (0x9 << 4);
	\end{lstlisting}
	
	\textbf{Was passiert hier?}
	\begin{itemize}
		\item \texttt{0x9} $\Rightarrow$ \texttt{0b1001} (Unser neuer Wert für 10MHz AF-Out)
		\item \texttt{<< 4} $\Rightarrow$ "Schiebe den Wert an Bit-Position 4"
		\item \texttt{(0x9 << 4)} $\Rightarrow$ \texttt{0b...10010000} (Die "Setz-Maske")
		\item \texttt{|=} $\Rightarrow$ "Bitweise ODER-Zuweisung"
		\item \textit{(Die Nullen werden mit \texttt{1001} überschrieben)}
	\end{itemize}
\end{frame}

\begin{frame}{Exkurs: Baudrate (Teil 1: Die Formel)}
	\textbf{Das Problem:}
	\begin{itemize}
		\item Wir wollen 9600 Baud (Bits/s) einstellen.
		\item Wir müssen einen \textbf{Divisor} (Teiler) berechnen, der unseren Systemtakt ($f_{CLK}$) auf 9600 herunterbricht.
	\end{itemize}
	
	\textbf{Die Formel (aus RM0008):}
	\begin{itemize}
		\item $\text{Baud} = f_{CLK} / (16 \times \text{USARTDIV})$
	\end{itemize}
	
	\textbf{Schritt 1: Nach \texttt{USARTDIV} auflösen}
	\begin{itemize}
		\item $f_{CLK} = 8.000.000$ (Unser 8MHz HSI)
		\item $\text{USARTDIV} = 8.000.000 / (16 \times 9600)$
		\item $\text{USARTDIV} = 8.000.000 / 153.600$
		\item $\text{USARTDIV} = \textbf{52.0833...}$
	\end{itemize}
\end{frame}

\begin{frame}{Exkurs: Baudrate (Teil 2: Das \texttt{BRR} Register)}
	\textbf{Problem:} Wie speichern wir \textbf{52.083} in einem 16-Bit Register?
	
	\medskip
	\textbf{Lösung:} Das \texttt{BRR} (Baud Rate Register) ist aufgeteilt:
	
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			Bits & \textbf{[15 : 4]} (12 Bits) & \textbf{[3 : 0]} (4 Bits) \\ \hline
			Inhalt & \texttt{DIV\_Mantissa} & \texttt{DIV\_Fraction} \\ 
			Bedeutung & Ganzzahl-Teil & Bruch-Teil (16tel) \\ \hline
		\end{tabular}
	\end{center}
	
	\medskip
	\textbf{Schritt 2: Unsere Zahl \texttt{52.083} aufteilen}
	\begin{itemize}
		\item \textbf{Mantisse:} Der Ganzzahl-Teil ist \textbf{52} $\Rightarrow$ \texttt{0x34}
		\item \textbf{Fraktion:} Der Bruch-Teil ist \textbf{0.083...}
		\item \textit{Umrechnung in 4-Bit-Wert:} $0.083 \times 16 = 1.33...$
		\item \textit{Wir runden auf:} \textbf{1} $\Rightarrow$ \texttt{0x01}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exkurs: Baudrate (Teil 3: Der Code)}
	\textbf{Schritt 3: Die Teile im Code zusammensetzen}
	\begin{itemize}
		\item Mantisse = \texttt{0x34} (52)
		\item Fraktion = \texttt{0x01} (1)
	\end{itemize}
	
	\bigskip
	\begin{lstlisting}[language=C, style=mystyle]
		USART1->BRR = (0x34 << 4) | 0x01;
	\end{lstlisting}
	
	\textbf{Was passiert hier?}
	\begin{itemize}
		\item \texttt{(0x34 << 4)} $\Rightarrow$ \texttt{0x340}
		\item Die Mantisse (52) wird 4 Bits nach links geschoben.
		\item \textit{(Binär: \texttt{...0011 0100 0000})}
		
		\medskip
		\item \texttt{| 0x01} $\Rightarrow$ \texttt{0x341}
		\item Die Fraktion (1) wird mit ODER in die leeren 4 Bits \texttt{[3:0]} eingefügt.
		\item \textit{(Binär: \texttt{...0011 0100 0001})}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Exkurs: Baudrate (Teil 4: Das Ergebnis)}
	\textbf{Analyse von: \texttt{USART1->BRR = 0x341;}}
	
	\begin{itemize}
		\item Das Register hat jetzt den Wert \texttt{0x341}.
		\item Die Hardware liest das als:
		\begin{itemize}
			\item Mantisse = \texttt{0x34} = 52
			\item Fraktion = \texttt{0x1} = 1
		\end{itemize}
		\item Der resultierende Divisor ist: $52 + (1/16) = \textbf{52.0625}$
	\end{itemize}
	
	\medskip
	\textbf{Vergleich:}
	\begin{itemize}
		\item Gewünschter Divisor: 52.0833...
		\item Erreichter Divisor: 52.0625
	\end{itemize}
	\rightarrow \textit{Die Abweichung ist < 0.1\%, was für UART perfekt ist.}
\end{frame}

\section{Praxis \& Übung}

\begin{frame}[fragile]{Praxis: Der "Echo-Bot"}
	\textbf{Test 2: Alle Teile (SysTick, LED, UART) zusammen}
	
	\medskip
	\textbf{Ziel:} Der MCU soll jedes empfangene UART-Zeichen zurücksenden (Echo) und dabei die LED togglen.
	
	\bigskip
	\textbf{Auszug aus der \texttt{main()}-Schleife:}
	\begin{lstlisting}[language=C, style=mystyle]
		while (1)
		{
			// 1. Warte blockierend, bis ein Zeichen reinkommt
			char c = UART1_GetChar();
			// 2. Sende dasselbe Zeichen sofort zurück (Echo)
			UART1_SendChar(c);
			// 3. Toggle die LED als visuelles Feedback
			LED_Toggle();
		}
	\end{lstlisting}
	
	\medskip
	\textbf{Hardware-Setup:} USB-UART-Konverter (FTDI, CH340)
	\begin{itemize}
		\item Konverter TX $\rightarrow$ Blue Pill PA10 (RX)
		\item Konverter RX $\rightarrow$ Blue Pill PA9 (TX)
		\item Konverter GND $\rightarrow$ Blue Pill GND
	\end{itemize}
\end{frame}


\begin{frame}{Übung: "Morse-Bot" (Teil 1: Regeln)}
	\textbf{Ziel:} Erweitere den "Echo-Bot" zum "Morse-Bot".
	
	\medskip
	\textbf{Anforderung:} Empfange ein Zeichen per UART, gib es als Morse-Code auf der LED aus.
	
	\medskip
	\textbf{Basis-Timing:}
	\begin{itemize}
		\item \texttt{DIT\_MS = 100} (z.B. 100 Millisekunden)
	\end{itemize}
	
	\textbf{Morse-Regeln:}
	\begin{itemize}
		\item \textbf{Dit (Punkt):} LED AN (1 * \texttt{DIT\_MS}), LED AUS (1 * \texttt{DIT\_MS})
		\item \textbf{Dah (Strich):} LED AN (3 * \texttt{DIT\_MS}), LED AUS (1 * \texttt{DIT\_MS})
		\item \textbf{Pause (Buchstaben):} (3 * \texttt{DIT\_MS})
		\item \textbf{Pause (Wort/Space):} (7 * \texttt{DIT\_MS})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Übung: "Morse-Bot" (Teil 2: Aufgaben)}
	\textbf{Aufgaben:}
	\begin{enumerate}
		\item Erstelle zwei neue Funktionen:
		\item \texttt{void morse\_dit(void)}
		\item \texttt{void morse\_dah(void)}
		\item \textit{(Diese rufen \texttt{LED\_On()}, \texttt{LED\_Off()} und \texttt{Delay\_ms()} auf)}
		
		\medskip
		\item Erstelle eine Funktion \texttt{void morse\_char(char c)}.
		\item Nutze ein \texttt{switch (c)} Statement.
		\item Implementiere (z.B.): 'S' (\texttt{...}), 'O' (\texttt{---}), 'A' (\texttt{.-})
		
		\medskip
		\item Ändere deine \texttt{main()}-Schleife:
		\item \texttt{char c = UART1\_GetChar();}
		\item \texttt{UART1\_SendChar(c);} // Echo (gut für Debugging)
		\item \texttt{morse\_char(c);}
		\item \texttt{Delay\_ms(DIT\_MS * 3);} // Pause nach dem Buchstaben
	\end{enumerate}
\end{frame}

\section{Debugging \& Ausblick}

\begin{frame}[fragile]{Debugging (Falle 1): UART-TX (Senden) ging nicht}
	\textbf{Problem:} Der "Lebenszeichen"-Test (\texttt{UART1\_SendChar('!')}) sendet nichts. Die TX-Leitung (PA9) bleibt still.
	
	\bigskip
	\textbf{Die Ursache: Register-Tippfehler}
	\begin{itemize}
		\item \texttt{CRH} = Control Register \textbf{High} (Pins 8-15)
		\item \texttt{CRL} = Control Register \textbf{Low} (Pins 0-7)
	\end{itemize}
	
	\bigskip
	\textbf{Der fehlerhafte Code:}
	\begin{lstlisting}[language=C, style=mystyle]
		// Pin 9 (TX) Konfiguration
		GPIOA->CRH &= ~(0xF << 4); // Löscht Bits für Pin 9 im CRH (Korrekt)
		GPIOA->CRL |= (0x9 << 4); // Schreibt Bits für Pin 1 im CRL (FATALER FEHLER!)
	\end{lstlisting}
	
	\medskip
	\textbf{Erkenntnis:} Pin 9 (TX) war \texttt{0000} (Input Analog) und konnte nicht senden. Pin 1 wurde stattdessen (sinnlos) konfiguriert.
\end{frame}

% --- HIER DIE AUFGETEILTEN FOLIEN ---

\begin{frame}[fragile]{Debugging (Falle 2): UART-RX (Problem)}
	\textbf{Problem:} Der Code (z.B. "Echo-Bot") scheint "eingefroren". Das Terminal bleibt leer.
	
	\bigskip
	\textbf{Der (vermeintliche) Fehler:}
	\begin{lstlisting}[language=C, style=mystyle]
		while (1)
		{
			// HIER WARTET DAS PROGRAMM!
			char c = UART1_GetChar(); 
			
			// Diese Zeilen werden NIE erreicht,
			// bis ein Zeichen empfangen wird.
			UART1_SendChar('!'); 
			LED_Toggle();
		}
	\end{lstlisting}
\end{frame}

\begin{frame}{Debugging (Falle 2): UART-RX (Erkenntnis)}
	\textbf{Erkenntnis: Das ist kein Fehler, das ist das Design!}
	\begin{itemize}
		\item Unsere Funktion \texttt{UART1\_GetChar()} ist \textbf{blockierend}.
		\item Sie wartet in ihrer *eigenen* \texttt{while}-Schleife auf das \texttt{RXNE}-Flag.
		\item Das Programm "hängt" wie erwartet und wartet auf Input.
	\end{itemize}
	
	\medskip
	\textbf{Beste Debug-Strategie (Der "Lebenszeichen"-Test):}
	\begin{itemize}
		\item Teste Senden (TX) *immer* zuerst und isoliert, z.B. mit einer 1-Sekunden-Schleife, \textit{bevor} du auf Empfang (RX) wartest.
	\end{itemize}
\end{frame}

% --- HIER IST DIE NEUE FOLIE ---

\begin{frame}[fragile]{Debugging (Falle 3): C-Syntax \& Compiler-Fehler}
	\textbf{Problem 1 (Fatal):} Linker-Fehler: \texttt{undefined reference to 'tolwer'}
	\begin{itemize}
		\item \textbf{Ursache:} Simpler Tippfehler. Es heißt \texttt{tolower()}.
		\item \textbf{Erkenntnis:} Der Linker (\texttt{ld}) bricht ab, wenn eine Funktion zwar deklariert (oder implizit angenommen), aber nirgends \textit{definiert} wurde.
	\end{itemize}
	
	\bigskip
	\textbf{Problem 2 (Warnung):} Compiler-Warnung: \texttt{expected 'char' but argument is 'char *'}
	\begin{itemize}
		\item \textbf{Ursache:} \texttt{UART1\_SendChar("R");} statt \texttt{UART1\_SendChar('R');}
		\item \textbf{Zentrale C-Erkenntnis:}
		\begin{itemize}
			\item \texttt{'R'} (einfach): Ist ein \texttt{char}. Eine einzelne Zahl (ASCII-Wert).
			\item \texttt{"R"} (doppelt): Ist ein \texttt{char*}. Ein Zeiger auf einen String (\texttt{\{'R', '\textbackslash{}0'\}}) im Speicher.
		\end{itemize}
	\end{itemize}
\end{frame}

% --- HIER DIE AUFGETEILTEN FOLIEN ---

\begin{frame}{Recap: Was wir gelernt haben}
	\textbf{Gelernt:}
	\begin{enumerate}
		\item \texttt{SysTick} ist die CMSIS-Standard für Timing (\texttt{delay}).
		\item \texttt{volatile} ist essenziell bei geteilten Variablen (ISR vs. main).
		\item \textbf{Bit-Masking:} Der \texttt{\&= \~...} und \texttt{|= ...} Tanz (Read-Modify-Write).
		\item \textbf{Baudrate:} Wie man $f_{CLK}$ und Divisor (Mantisse/Fraktion) ins \texttt{BRR} Register rechnet.
		\item \textbf{C-Syntax:} Der Unterschied zwischen \texttt{'c'} (char) und \texttt{"c"} (char*).
		\item \textbf{Debugging:} \texttt{CRH} vs. \texttt{CRL}, und \texttt{TX}-Test vor \texttt{RX}-Test.
	\end{enumerate}
\end{frame}

\begin{frame}{Ausblick: Das Problem mit "Blocking"}
	\textbf{Das GROSSE Problem unseres jetzigen Codes:}
	\begin{itemize}
		\item \texttt{UART1\_GetChar()} ist \textbf{blockierend}.
		\item \texttt{Delay\_ms()} ist \textbf{blockierend}.
		\item \textit{Das System "steht still", während es wartet oder morst. Es verpasst in dieser Zeit neue UART-Daten!}
	\end{itemize}
	
	\bigskip
	\textbf{Ausblick (Teil 3): Die Lösung}
	\begin{itemize}
		\item \textbf{Interrupts:} UART-Empfang im Hintergrund (ISR).
		\item \textbf{Ringbuffer:} Daten zwischenspeichern.
		\item \textbf{State Machines:} Morsen, ohne die \texttt{main}-Schleife zu blockieren.
	\end{itemize}
\end{frame}
\section{Aufgabe 3: Non-Blocking Design (Interrupts)}

\begin{frame}{Teil 3: Das "Blocking"-Problem}
	\textbf{Analyse unseres Morse-Bots (Teil 2):}
	\begin{itemize}
		\item Die CPU ist "taub", während sie morst.
		\item Sie hängt in \texttt{Delay\_ms()} fest.
		\item In dieser Zeit kann sie \texttt{UART1\_GetChar()} nicht aufrufen.
	\end{itemize}
	
	\bigskip
	\textbf{Das Problem: UART Overrun}
	\begin{enumerate}
		\item User tippt 'S' $\rightarrow$ \texttt{morse\_char('s')} startet (blockiert ca. 500ms).
		\item User tippt 'O' (während 'S' morst).
		\item Das 'O' trifft auf einen "tauben" MCU. Das UART-Hardware-Register (DR) wird überschrieben, bevor die CPU es lesen kann.
		\item \textbf{Datenverlust.}
	\end{enumerate}
	
	\medskip
	\textbf{Die Lösung: Entkopplung von Empfang \& Verarbeitung.}
	\begin{itemize}
		\item \textbf{Empfang (schnell):} Muss im Hintergrund passieren (Interrupt).
		\item \textbf{Verarbeitung (langsam):} Darf die \texttt{main()}-Schleife machen.
	\end{itemize}
\end{frame}

\begin{frame}{Architektur: Interrupt \& Ringbuffer}
	\textbf{Unsere neue Architektur (Der "Briefkasten"):}
	
	\medskip
	\textbf{1. Der UART RX-Interrupt (Die "Klingel")}
	\begin{itemize}
		\item Wir konfigurieren den UART so, dass er einen Interrupt (\texttt{USART1\_IRQHandler}) auslöst, sobald ein Byte ankommt (\texttt{RXNE}-Flag).
		\item Die CPU stoppt kurz ihre Hauptarbeit (Morsen).
	\end{itemize}
	
	\medskip
	\textbf{2. Der Ringbuffer (Der "Briefkasten")}
	\begin{itemize}
		\item Die Interrupt-Routine (ISR) ist extrem schnell:
		\item Sie liest das Byte aus \texttt{USART1->DR}.
		\item Sie "wirft" das Byte in einen Puffer (den Ringbuffer).
		\item Sie ist sofort wieder weg.
	\end{itemize}
	
	\medskip
	\textbf{3. Die \texttt{main()}-Schleife (Der "Leser")}
	\begin{itemize}
		\item Die \texttt{main()}-Schleife (Morse-Logik) schaut in ihrer Freizeit in den Ringbuffer, ob "Post" da ist und holt sich das nächste Byte ab.
	\end{itemize}
\end{frame}

\begin{frame}{Architektur: Was ist ein Ringbuffer?}
	\textbf{Auch: Circular Buffer oder FIFO (First-In, First-Out)}
	
	\medskip
	\begin{itemize}
		\item Ein einfaches Array im RAM (z.B. 32 Bytes groß).
		\item Zwei "Zeiger" (eigentlich nur Index-Variablen):
		\begin{itemize}
			\item \texttt{head}: Wo die ISR das \textit{nächste Byte hineinschreibt}.
			\item \texttt{tail}: Wo die \texttt{main}-Loop das \textit{nächste Byte herausliest}.
		\end{itemize}
		\item Wenn \texttt{head} oder \texttt{tail} das Ende des Arrays erreichen, "wrappen" sie zurück auf 0.
		\item \textbf{Zustände:}
		\begin{itemize}
			\item Puffer leer: \texttt{head == tail}
			\item Puffer voll: \texttt{head} ist "kurz vor" \texttt{tail}
		\end{itemize}
	\end{itemize}
	
	\medskip
	\textbf{WICHTIG (Race Condition):}
	\begin{itemize}
		\item \texttt{head} wird von einer ISR geändert.
		\item \texttt{tail} wird von \texttt{main} geändert.
		\item $\rightarrow$ Die \texttt{head/tail} Index-Variablen müssen \textbf{\texttt{volatile}} sein!
	\end{itemize}
\end{frame}
\section{Aufgabe 3: Non-Blocking Design (Interrupts)}
% (Wir gehen davon aus, dass die Folien zum Ringbuffer schon existieren)

\begin{frame}[fragile]{Schritt 1: UART-Interrupt aktivieren (Die "Klingel")}
	\textbf{Ziel:} Wir wollen nicht mehr aktiv auf \texttt{RXNE} warten (Polling).
	
	\medskip
	\textbf{Lösung:} Wir sagen dem UART, er soll einen Interrupt auslösen, sobald das \texttt{RXNE}-Flag (Receive Register Not Empty) gesetzt wird.
	
	\bigskip
	\textbf{Wie? In unserer \texttt{UART1\_Init()}-Funktion.}
	\begin{itemize}
		\item Wir müssen ein Bit im \texttt{USART1->CR1} (Control Register 1) setzen.
		\item Das Bit heißt: \textbf{\texttt{RXNEIE}} (RXNE Interrupt Enable)
	\end{itemize}
	
	\bigskip
	\textbf{Der Code (Ergänzung in \texttt{UART1\_Init()}):}
	\begin{lstlisting}[language=C, style=mystyle]
		// Am Ende von UART1_Init(), nach dem Aktivieren von UE, TE, RE:
		// Aktiviere den "Receive Register Not Empty" Interrupt
		USART1->CR1 |= USART_CR1_RXNEIE;
	\end{lstlisting}
	
	\medskip
	\textbf{Ergebnis:} Ab jetzt sendet der UART ein "Interrupt-Signal" an den "Chef", wenn ein Byte ankommt.
\end{frame}

\begin{frame}[fragile]{Schritt 2: Den "Chef" (NVIC) informieren}
	\textbf{Problem:} Nur weil der UART "klingelt", heißt das nicht, dass die CPU (der "Chef") zuhört.
	
	\medskip
	\textbf{Lösung: Der NVIC (Nested Vectored Interrupt Controller)}
	\begin{itemize}
		\item Der NVIC ist der Interrupt-Manager direkt im Cortex-M Kern.
		\item Er verwaltet *alle* Interrupt-Quellen (Timer, UARTs, GPIOs...).
		\item Wir müssen dem NVIC sagen: "Hey, die Klingel von \texttt{USART1} ist uns wichtig. Stell sie an."
	\end{itemize}
	
	\bigskip
	\textbf{Der Code (Am Anfang von \texttt{main()})}
	\begin{lstlisting}[language=C, style=mystyle]
		// Wir müssen dem NVIC sagen, dass er den USART1-Interrupt
		// global aktivieren soll.
		// (CMSIS-Core Funktion)
		NVIC_EnableIRQ(USART1_IRQn);
	\end{lstlisting}
	
	\medskip
	\textbf{Ergebnis:} Wenn \texttt{USART1} jetzt \texttt{RXNEIE} auslöst, wird die CPU ihre Arbeit unterbrechen und zur zuständigen ISR springen.
\end{frame}

\begin{frame}{Schritt 3: Der "Postbote" (Die ISR)}
	\textbf{Ziel:} Die Interrupt Service Routine (ISR) muss *blitzschnell* sein.
	\textbf{Was passiert:}
	\begin{enumerate}
		\item Ein Byte kommt an.
		\item \texttt{RXNE}-Flag wird von Hardware gesetzt.
		\item \texttt{RXNEIE}-Bit ist an $\rightarrow$ UART sendet Signal an NVIC.
		\item \texttt{USART1\_IRQn} ist im NVIC an $\rightarrow$ CPU stoppt \texttt{main()}, springt zur ISR.
	\end{enumerate}
	\textbf{Die Implementierung (in \texttt{stm32f1xx\_it.c})}
\end{frame}
\begin{frame}[fragile]{Schritt 3: Der "Postbote" (Die ISR)}
	\begin{lstlisting}[language=C, style=mystyle]
	// Prototyp der Funktion ist in startup_stm32...s
	void USART1_IRQHandler(void)
	{
		// 1. Prüfen, ob WIRKLICH ein RXNE-Interrupt der Grund war
		if ( (USART1->SR & USART_SR_RXNE) )
		{
			// 2. Byte aus dem Datenregister lesen
			//    (WICHTIG: Das löscht das RXNE-Flag automatisch!)
			uint8_t byte = (uint8_t)(USART1->DR & 0xFF);
			// 3. Byte in unseren "Briefkasten" werfen
			RingBuffer_Write(&g_rxBuffer, byte);
		}
	}
\end{lstlisting}
\end{frame}
\section{Architektur (Speicher)}

\begin{frame}{Exkurs: Flash vs. RAM (Die "Endurance"-Frage)}
	\textbf{Deine Frage:} "Killt der Ringbuffer nicht meine Flash Endurance?"
	
	\medskip
	\textbf{Antwort: Nein! Er killt sie \textit{null}, weil er \textit{nicht} im Flash liegt.}
	
	\medskip
	\begin{columns}
		\column{0.5\textwidth}
		\textbf{1. Flash (Programmspeicher)}
		\begin{itemize}
			\item \textbf{Analogie:} Festplatte
			\item \textbf{Nutzung:} Dein Code (\texttt{.bin}), \texttt{const}
			\item \textbf{Eigenschaft:} Non-Volatile
			\item \textbf{Problem:} \textbf{Limitierte} Zyklen (10k-100k), langsames Schreiben.
			\item \textit{Wird nur beim Flashen genutzt.}
		\end{itemize}
		
		\column{0.5\textwidth}
		\textbf{2. SRAM (Arbeitsspeicher)}
		\begin{itemize}
			\item \textbf{Analogie:} RAM / Arbeitsspeicher
			\item \textbf{Nutzung:} Alle C-Variablen (\texttt{g\_msTicks}, unser Puffer-Array)
			\item \textbf{Eigenschaft:} Volatile
			\item \textbf{Vorteil:} \textbf{Unlimitierte} Zyklen, extrem schnelles Schreiben.
			\item \textit{Wird permanent genutzt.}
		\end{itemize}
	\end{columns}
	
	\bigskip
	\textbf{Fazit: Unser Ringbuffer liegt komplett im SRAM. Schreib-Operationen im RAM sind "kostenlos" und "verschleißfrei".}
\end{frame}
\end{document}